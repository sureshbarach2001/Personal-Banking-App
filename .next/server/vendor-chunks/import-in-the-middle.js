/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/import-in-the-middle";
exports.ids = ["vendor-chunks/import-in-the-middle"];
exports.modules = {

/***/ "(ssr)/./node_modules/import-in-the-middle/index.js":
/*!****************************************************!*\
  !*** ./node_modules/import-in-the-middle/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst parse = __webpack_require__(/*! module-details-from-path */ \"(ssr)/./node_modules/module-details-from-path/index.js\")\nconst { fileURLToPath } = __webpack_require__(/*! url */ \"url\")\nconst { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\n\nconst {\n  importHooks,\n  specifiers,\n  toHook\n} = __webpack_require__(/*! ./lib/register */ \"(ssr)/./node_modules/import-in-the-middle/lib/register.js\")\n\nfunction addHook (hook) {\n  importHooks.push(hook)\n  toHook.forEach(([name, namespace]) => hook(name, namespace))\n}\n\nfunction removeHook (hook) {\n  const index = importHooks.indexOf(hook)\n  if (index > -1) {\n    importHooks.splice(index, 1)\n  }\n}\n\nfunction callHookFn (hookFn, namespace, name, baseDir) {\n  const newDefault = hookFn(namespace, name, baseDir)\n  if (newDefault && newDefault !== namespace) {\n    namespace.default = newDefault\n  }\n}\n\nlet sendModulesToLoader\n\n/**\n * EXPERIMENTAL\n * This feature is experimental and may change in minor versions.\n * **NOTE** This feature is incompatible with the {internals: true} Hook option.\n *\n * Creates a message channel with a port that can be used to add hooks to the\n * list of exclusively included modules.\n *\n * This can be used to only wrap modules that are Hook'ed, however modules need\n * to be hooked before they are imported.\n *\n * ```ts\n * import { register } from 'module'\n * import { Hook, createAddHookMessageChannel } from 'import-in-the-middle'\n *\n * const { registerOptions, waitForAllMessagesAcknowledged } = createAddHookMessageChannel()\n *\n * register('import-in-the-middle/hook.mjs', import.meta.url, registerOptions)\n *\n * Hook(['fs'], (exported, name, baseDir) => {\n *   // Instrument the fs module\n * })\n *\n * // Ensure that the loader has acknowledged all the modules\n * // before we allow execution to continue\n * await waitForAllMessagesAcknowledged()\n * ```\n */\nfunction createAddHookMessageChannel () {\n  const { port1, port2 } = new MessageChannel()\n  let pendingAckCount = 0\n  let resolveFn\n\n  sendModulesToLoader = (modules) => {\n    pendingAckCount++\n    port1.postMessage(modules)\n  }\n\n  port1.on('message', () => {\n    pendingAckCount--\n\n    if (resolveFn && pendingAckCount <= 0) {\n      resolveFn()\n    }\n  }).unref()\n\n  function waitForAllMessagesAcknowledged () {\n    // This timer is to prevent the process from exiting with code 13:\n    // 13: Unsettled Top-Level Await.\n    const timer = setInterval(() => { }, 1000)\n    const promise = new Promise((resolve) => {\n      resolveFn = resolve\n    }).then(() => { clearInterval(timer) })\n\n    if (pendingAckCount === 0) {\n      resolveFn()\n    }\n\n    return promise\n  }\n\n  const addHookMessagePort = port2\n  const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] }\n\n  return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged }\n}\n\nfunction Hook (modules, options, hookFn) {\n  if ((this instanceof Hook) === false) return new Hook(modules, options, hookFn)\n  if (typeof modules === 'function') {\n    hookFn = modules\n    modules = null\n    options = null\n  } else if (typeof options === 'function') {\n    hookFn = options\n    options = null\n  }\n  const internals = options ? options.internals === true : false\n\n  if (sendModulesToLoader && Array.isArray(modules)) {\n    sendModulesToLoader(modules)\n  }\n\n  this._iitmHook = (name, namespace) => {\n    const filename = name\n    const isBuiltin = name.startsWith('node:')\n    let baseDir\n\n    if (isBuiltin) {\n      name = name.replace(/^node:/, '')\n    } else {\n      if (name.startsWith('file://')) {\n        try {\n          name = fileURLToPath(name)\n        } catch (e) {}\n      }\n      const details = parse(name)\n      if (details) {\n        name = details.name\n        baseDir = details.basedir\n      }\n    }\n\n    if (modules) {\n      for (const moduleName of modules) {\n        if (moduleName === name) {\n          if (baseDir) {\n            if (internals) {\n              name = name + path.sep + path.relative(baseDir, fileURLToPath(filename))\n            } else {\n              if (!baseDir.endsWith(specifiers.get(filename))) continue\n            }\n          }\n          callHookFn(hookFn, namespace, name, baseDir)\n        }\n      }\n    } else {\n      callHookFn(hookFn, namespace, name, baseDir)\n    }\n  }\n\n  addHook(this._iitmHook)\n}\n\nHook.prototype.unhook = function () {\n  removeHook(this._iitmHook)\n}\n\nmodule.exports = Hook\nmodule.exports.Hook = Hook\nmodule.exports.addHook = addHook\nmodule.exports.removeHook = removeHook\nmodule.exports.createAddHookMessageChannel = createAddHookMessageChannel\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsc0NBQWdCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlGQUFnQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsS0FBSyxlQUFlLHNCQUFzQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUSxpQ0FBaUM7O0FBRXJFLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvaW5kZXguanM/MzUwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmxlc3MgZXhwbGljaXRseSBzdGF0ZWQgb3RoZXJ3aXNlIGFsbCBmaWxlcyBpbiB0aGlzIHJlcG9zaXRvcnkgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIExpY2Vuc2UuXG4vL1xuLy8gVGhpcyBwcm9kdWN0IGluY2x1ZGVzIHNvZnR3YXJlIGRldmVsb3BlZCBhdCBEYXRhZG9nIChodHRwczovL3d3dy5kYXRhZG9naHEuY29tLykuIENvcHlyaWdodCAyMDIxIERhdGFkb2csIEluYy5cblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCdtb2R1bGUtZGV0YWlscy1mcm9tLXBhdGgnKVxuY29uc3QgeyBmaWxlVVJMVG9QYXRoIH0gPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgeyBNZXNzYWdlQ2hhbm5lbCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCB7XG4gIGltcG9ydEhvb2tzLFxuICBzcGVjaWZpZXJzLFxuICB0b0hvb2tcbn0gPSByZXF1aXJlKCcuL2xpYi9yZWdpc3RlcicpXG5cbmZ1bmN0aW9uIGFkZEhvb2sgKGhvb2spIHtcbiAgaW1wb3J0SG9va3MucHVzaChob29rKVxuICB0b0hvb2suZm9yRWFjaCgoW25hbWUsIG5hbWVzcGFjZV0pID0+IGhvb2sobmFtZSwgbmFtZXNwYWNlKSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSG9vayAoaG9vaykge1xuICBjb25zdCBpbmRleCA9IGltcG9ydEhvb2tzLmluZGV4T2YoaG9vaylcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICBpbXBvcnRIb29rcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2tGbiAoaG9va0ZuLCBuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpIHtcbiAgY29uc3QgbmV3RGVmYXVsdCA9IGhvb2tGbihuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpXG4gIGlmIChuZXdEZWZhdWx0ICYmIG5ld0RlZmF1bHQgIT09IG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZS5kZWZhdWx0ID0gbmV3RGVmYXVsdFxuICB9XG59XG5cbmxldCBzZW5kTW9kdWxlc1RvTG9hZGVyXG5cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKiBUaGlzIGZlYXR1cmUgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIG1pbm9yIHZlcnNpb25zLlxuICogKipOT1RFKiogVGhpcyBmZWF0dXJlIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSB7aW50ZXJuYWxzOiB0cnVlfSBIb29rIG9wdGlvbi5cbiAqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSBjaGFubmVsIHdpdGggYSBwb3J0IHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGhvb2tzIHRvIHRoZVxuICogbGlzdCBvZiBleGNsdXNpdmVseSBpbmNsdWRlZCBtb2R1bGVzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gb25seSB3cmFwIG1vZHVsZXMgdGhhdCBhcmUgSG9vaydlZCwgaG93ZXZlciBtb2R1bGVzIG5lZWRcbiAqIHRvIGJlIGhvb2tlZCBiZWZvcmUgdGhleSBhcmUgaW1wb3J0ZWQuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnbW9kdWxlJ1xuICogaW1wb3J0IHsgSG9vaywgY3JlYXRlQWRkSG9va01lc3NhZ2VDaGFubmVsIH0gZnJvbSAnaW1wb3J0LWluLXRoZS1taWRkbGUnXG4gKlxuICogY29uc3QgeyByZWdpc3Rlck9wdGlvbnMsIHdhaXRGb3JBbGxNZXNzYWdlc0Fja25vd2xlZGdlZCB9ID0gY3JlYXRlQWRkSG9va01lc3NhZ2VDaGFubmVsKClcbiAqXG4gKiByZWdpc3RlcignaW1wb3J0LWluLXRoZS1taWRkbGUvaG9vay5tanMnLCBpbXBvcnQubWV0YS51cmwsIHJlZ2lzdGVyT3B0aW9ucylcbiAqXG4gKiBIb29rKFsnZnMnXSwgKGV4cG9ydGVkLCBuYW1lLCBiYXNlRGlyKSA9PiB7XG4gKiAgIC8vIEluc3RydW1lbnQgdGhlIGZzIG1vZHVsZVxuICogfSlcbiAqXG4gKiAvLyBFbnN1cmUgdGhhdCB0aGUgbG9hZGVyIGhhcyBhY2tub3dsZWRnZWQgYWxsIHRoZSBtb2R1bGVzXG4gKiAvLyBiZWZvcmUgd2UgYWxsb3cgZXhlY3V0aW9uIHRvIGNvbnRpbnVlXG4gKiBhd2FpdCB3YWl0Rm9yQWxsTWVzc2FnZXNBY2tub3dsZWRnZWQoKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbCAoKSB7XG4gIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKVxuICBsZXQgcGVuZGluZ0Fja0NvdW50ID0gMFxuICBsZXQgcmVzb2x2ZUZuXG5cbiAgc2VuZE1vZHVsZXNUb0xvYWRlciA9IChtb2R1bGVzKSA9PiB7XG4gICAgcGVuZGluZ0Fja0NvdW50KytcbiAgICBwb3J0MS5wb3N0TWVzc2FnZShtb2R1bGVzKVxuICB9XG5cbiAgcG9ydDEub24oJ21lc3NhZ2UnLCAoKSA9PiB7XG4gICAgcGVuZGluZ0Fja0NvdW50LS1cblxuICAgIGlmIChyZXNvbHZlRm4gJiYgcGVuZGluZ0Fja0NvdW50IDw9IDApIHtcbiAgICAgIHJlc29sdmVGbigpXG4gICAgfVxuICB9KS51bnJlZigpXG5cbiAgZnVuY3Rpb24gd2FpdEZvckFsbE1lc3NhZ2VzQWNrbm93bGVkZ2VkICgpIHtcbiAgICAvLyBUaGlzIHRpbWVyIGlzIHRvIHByZXZlbnQgdGhlIHByb2Nlc3MgZnJvbSBleGl0aW5nIHdpdGggY29kZSAxMzpcbiAgICAvLyAxMzogVW5zZXR0bGVkIFRvcC1MZXZlbCBBd2FpdC5cbiAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMTAwMClcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGbiA9IHJlc29sdmVcbiAgICB9KS50aGVuKCgpID0+IHsgY2xlYXJJbnRlcnZhbCh0aW1lcikgfSlcblxuICAgIGlmIChwZW5kaW5nQWNrQ291bnQgPT09IDApIHtcbiAgICAgIHJlc29sdmVGbigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGNvbnN0IGFkZEhvb2tNZXNzYWdlUG9ydCA9IHBvcnQyXG4gIGNvbnN0IHJlZ2lzdGVyT3B0aW9ucyA9IHsgZGF0YTogeyBhZGRIb29rTWVzc2FnZVBvcnQsIGluY2x1ZGU6IFtdIH0sIHRyYW5zZmVyTGlzdDogW2FkZEhvb2tNZXNzYWdlUG9ydF0gfVxuXG4gIHJldHVybiB7IHJlZ2lzdGVyT3B0aW9ucywgYWRkSG9va01lc3NhZ2VQb3J0LCB3YWl0Rm9yQWxsTWVzc2FnZXNBY2tub3dsZWRnZWQgfVxufVxuXG5mdW5jdGlvbiBIb29rIChtb2R1bGVzLCBvcHRpb25zLCBob29rRm4pIHtcbiAgaWYgKCh0aGlzIGluc3RhbmNlb2YgSG9vaykgPT09IGZhbHNlKSByZXR1cm4gbmV3IEhvb2sobW9kdWxlcywgb3B0aW9ucywgaG9va0ZuKVxuICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBob29rRm4gPSBtb2R1bGVzXG4gICAgbW9kdWxlcyA9IG51bGxcbiAgICBvcHRpb25zID0gbnVsbFxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaG9va0ZuID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cbiAgY29uc3QgaW50ZXJuYWxzID0gb3B0aW9ucyA/IG9wdGlvbnMuaW50ZXJuYWxzID09PSB0cnVlIDogZmFsc2VcblxuICBpZiAoc2VuZE1vZHVsZXNUb0xvYWRlciAmJiBBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgc2VuZE1vZHVsZXNUb0xvYWRlcihtb2R1bGVzKVxuICB9XG5cbiAgdGhpcy5faWl0bUhvb2sgPSAobmFtZSwgbmFtZXNwYWNlKSA9PiB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBuYW1lXG4gICAgY29uc3QgaXNCdWlsdGluID0gbmFtZS5zdGFydHNXaXRoKCdub2RlOicpXG4gICAgbGV0IGJhc2VEaXJcblxuICAgIGlmIChpc0J1aWx0aW4pIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL15ub2RlOi8sICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuYW1lID0gZmlsZVVSTFRvUGF0aChuYW1lKVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgY29uc3QgZGV0YWlscyA9IHBhcnNlKG5hbWUpXG4gICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICBuYW1lID0gZGV0YWlscy5uYW1lXG4gICAgICAgIGJhc2VEaXIgPSBkZXRhaWxzLmJhc2VkaXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kdWxlcykge1xuICAgICAgZm9yIChjb25zdCBtb2R1bGVOYW1lIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgaWYgKG1vZHVsZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAoYmFzZURpcikge1xuICAgICAgICAgICAgaWYgKGludGVybmFscykge1xuICAgICAgICAgICAgICBuYW1lID0gbmFtZSArIHBhdGguc2VwICsgcGF0aC5yZWxhdGl2ZShiYXNlRGlyLCBmaWxlVVJMVG9QYXRoKGZpbGVuYW1lKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghYmFzZURpci5lbmRzV2l0aChzcGVjaWZpZXJzLmdldChmaWxlbmFtZSkpKSBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsSG9va0ZuKGhvb2tGbiwgbmFtZXNwYWNlLCBuYW1lLCBiYXNlRGlyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxIb29rRm4oaG9va0ZuLCBuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpXG4gICAgfVxuICB9XG5cbiAgYWRkSG9vayh0aGlzLl9paXRtSG9vaylcbn1cblxuSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKCkge1xuICByZW1vdmVIb29rKHRoaXMuX2lpdG1Ib29rKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvb2tcbm1vZHVsZS5leHBvcnRzLkhvb2sgPSBIb29rXG5tb2R1bGUuZXhwb3J0cy5hZGRIb29rID0gYWRkSG9va1xubW9kdWxlLmV4cG9ydHMucmVtb3ZlSG9vayA9IHJlbW92ZUhvb2tcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbCA9IGNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/import-in-the-middle/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/import-in-the-middle/lib/register.js":
/*!***********************************************************!*\
  !*** ./node_modules/import-in-the-middle/lib/register.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\nconst importHooks = [] // TODO should this be a Set?\nconst setters = new WeakMap()\nconst getters = new WeakMap()\nconst specifiers = new Map()\nconst toHook = []\n\nconst proxyHandler = {\n  set (target, name, value) {\n    return setters.get(target)[name](value)\n  },\n\n  get (target, name) {\n    if (name === Symbol.toStringTag) {\n      return 'Module'\n    }\n\n    const getter = getters.get(target)[name]\n\n    if (typeof getter === 'function') {\n      return getter()\n    }\n  },\n\n  defineProperty (target, property, descriptor) {\n    if ((!('value' in descriptor))) {\n      throw new Error('Getters/setters are not supported for exports property descriptors.')\n    }\n\n    return setters.get(target)[property](descriptor.value)\n  }\n}\n\nfunction register (name, namespace, set, get, specifier) {\n  specifiers.set(name, specifier)\n  setters.set(namespace, set)\n  getters.set(namespace, get)\n  const proxy = new Proxy(namespace, proxyHandler)\n  importHooks.forEach(hook => hook(name, proxy))\n  toHook.push([name, proxy])\n}\n\nexports.register = register\nexports.importHooks = importHooks\nexports.specifiers = specifiers\nexports.toHook = toHook\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvbGliL3JlZ2lzdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvbGliL3JlZ2lzdGVyLmpzP2RhYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RhdGVkIG90aGVyd2lzZSBhbGwgZmlsZXMgaW4gdGhpcyByZXBvc2l0b3J5IGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIDIuMCBMaWNlbnNlLlxuLy9cbi8vIFRoaXMgcHJvZHVjdCBpbmNsdWRlcyBzb2Z0d2FyZSBkZXZlbG9wZWQgYXQgRGF0YWRvZyAoaHR0cHM6Ly93d3cuZGF0YWRvZ2hxLmNvbS8pLiBDb3B5cmlnaHQgMjAyMSBEYXRhZG9nLCBJbmMuXG5cbmNvbnN0IGltcG9ydEhvb2tzID0gW10gLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBhIFNldD9cbmNvbnN0IHNldHRlcnMgPSBuZXcgV2Vha01hcCgpXG5jb25zdCBnZXR0ZXJzID0gbmV3IFdlYWtNYXAoKVxuY29uc3Qgc3BlY2lmaWVycyA9IG5ldyBNYXAoKVxuY29uc3QgdG9Ib29rID0gW11cblxuY29uc3QgcHJveHlIYW5kbGVyID0ge1xuICBzZXQgKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2V0dGVycy5nZXQodGFyZ2V0KVtuYW1lXSh2YWx1ZSlcbiAgfSxcblxuICBnZXQgKHRhcmdldCwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgIHJldHVybiAnTW9kdWxlJ1xuICAgIH1cblxuICAgIGNvbnN0IGdldHRlciA9IGdldHRlcnMuZ2V0KHRhcmdldClbbmFtZV1cblxuICAgIGlmICh0eXBlb2YgZ2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0dGVyKClcbiAgICB9XG4gIH0sXG5cbiAgZGVmaW5lUHJvcGVydHkgKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoKCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2V0dGVycy9zZXR0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBleHBvcnRzIHByb3BlcnR5IGRlc2NyaXB0b3JzLicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRlcnMuZ2V0KHRhcmdldClbcHJvcGVydHldKGRlc2NyaXB0b3IudmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXIgKG5hbWUsIG5hbWVzcGFjZSwgc2V0LCBnZXQsIHNwZWNpZmllcikge1xuICBzcGVjaWZpZXJzLnNldChuYW1lLCBzcGVjaWZpZXIpXG4gIHNldHRlcnMuc2V0KG5hbWVzcGFjZSwgc2V0KVxuICBnZXR0ZXJzLnNldChuYW1lc3BhY2UsIGdldClcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkobmFtZXNwYWNlLCBwcm94eUhhbmRsZXIpXG4gIGltcG9ydEhvb2tzLmZvckVhY2goaG9vayA9PiBob29rKG5hbWUsIHByb3h5KSlcbiAgdG9Ib29rLnB1c2goW25hbWUsIHByb3h5XSlcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyXG5leHBvcnRzLmltcG9ydEhvb2tzID0gaW1wb3J0SG9va3NcbmV4cG9ydHMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnNcbmV4cG9ydHMudG9Ib29rID0gdG9Ib29rXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/import-in-the-middle/lib/register.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/import-in-the-middle/index.js":
/*!****************************************************!*\
  !*** ./node_modules/import-in-the-middle/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst parse = __webpack_require__(/*! module-details-from-path */ \"(rsc)/./node_modules/module-details-from-path/index.js\")\nconst { fileURLToPath } = __webpack_require__(/*! url */ \"url\")\nconst { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\n\nconst {\n  importHooks,\n  specifiers,\n  toHook\n} = __webpack_require__(/*! ./lib/register */ \"(rsc)/./node_modules/import-in-the-middle/lib/register.js\")\n\nfunction addHook (hook) {\n  importHooks.push(hook)\n  toHook.forEach(([name, namespace]) => hook(name, namespace))\n}\n\nfunction removeHook (hook) {\n  const index = importHooks.indexOf(hook)\n  if (index > -1) {\n    importHooks.splice(index, 1)\n  }\n}\n\nfunction callHookFn (hookFn, namespace, name, baseDir) {\n  const newDefault = hookFn(namespace, name, baseDir)\n  if (newDefault && newDefault !== namespace) {\n    namespace.default = newDefault\n  }\n}\n\nlet sendModulesToLoader\n\n/**\n * EXPERIMENTAL\n * This feature is experimental and may change in minor versions.\n * **NOTE** This feature is incompatible with the {internals: true} Hook option.\n *\n * Creates a message channel with a port that can be used to add hooks to the\n * list of exclusively included modules.\n *\n * This can be used to only wrap modules that are Hook'ed, however modules need\n * to be hooked before they are imported.\n *\n * ```ts\n * import { register } from 'module'\n * import { Hook, createAddHookMessageChannel } from 'import-in-the-middle'\n *\n * const { registerOptions, waitForAllMessagesAcknowledged } = createAddHookMessageChannel()\n *\n * register('import-in-the-middle/hook.mjs', import.meta.url, registerOptions)\n *\n * Hook(['fs'], (exported, name, baseDir) => {\n *   // Instrument the fs module\n * })\n *\n * // Ensure that the loader has acknowledged all the modules\n * // before we allow execution to continue\n * await waitForAllMessagesAcknowledged()\n * ```\n */\nfunction createAddHookMessageChannel () {\n  const { port1, port2 } = new MessageChannel()\n  let pendingAckCount = 0\n  let resolveFn\n\n  sendModulesToLoader = (modules) => {\n    pendingAckCount++\n    port1.postMessage(modules)\n  }\n\n  port1.on('message', () => {\n    pendingAckCount--\n\n    if (resolveFn && pendingAckCount <= 0) {\n      resolveFn()\n    }\n  }).unref()\n\n  function waitForAllMessagesAcknowledged () {\n    // This timer is to prevent the process from exiting with code 13:\n    // 13: Unsettled Top-Level Await.\n    const timer = setInterval(() => { }, 1000)\n    const promise = new Promise((resolve) => {\n      resolveFn = resolve\n    }).then(() => { clearInterval(timer) })\n\n    if (pendingAckCount === 0) {\n      resolveFn()\n    }\n\n    return promise\n  }\n\n  const addHookMessagePort = port2\n  const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] }\n\n  return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged }\n}\n\nfunction Hook (modules, options, hookFn) {\n  if ((this instanceof Hook) === false) return new Hook(modules, options, hookFn)\n  if (typeof modules === 'function') {\n    hookFn = modules\n    modules = null\n    options = null\n  } else if (typeof options === 'function') {\n    hookFn = options\n    options = null\n  }\n  const internals = options ? options.internals === true : false\n\n  if (sendModulesToLoader && Array.isArray(modules)) {\n    sendModulesToLoader(modules)\n  }\n\n  this._iitmHook = (name, namespace) => {\n    const filename = name\n    const isBuiltin = name.startsWith('node:')\n    let baseDir\n\n    if (isBuiltin) {\n      name = name.replace(/^node:/, '')\n    } else {\n      if (name.startsWith('file://')) {\n        try {\n          name = fileURLToPath(name)\n        } catch (e) {}\n      }\n      const details = parse(name)\n      if (details) {\n        name = details.name\n        baseDir = details.basedir\n      }\n    }\n\n    if (modules) {\n      for (const moduleName of modules) {\n        if (moduleName === name) {\n          if (baseDir) {\n            if (internals) {\n              name = name + path.sep + path.relative(baseDir, fileURLToPath(filename))\n            } else {\n              if (!baseDir.endsWith(specifiers.get(filename))) continue\n            }\n          }\n          callHookFn(hookFn, namespace, name, baseDir)\n        }\n      }\n    } else {\n      callHookFn(hookFn, namespace, name, baseDir)\n    }\n  }\n\n  addHook(this._iitmHook)\n}\n\nHook.prototype.unhook = function () {\n  removeHook(this._iitmHook)\n}\n\nmodule.exports = Hook\nmodule.exports.Hook = Hook\nmodule.exports.addHook = addHook\nmodule.exports.removeHook = removeHook\nmodule.exports.createAddHookMessageChannel = createAddHookMessageChannel\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsc0NBQWdCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlGQUFnQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsS0FBSyxlQUFlLHNCQUFzQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUSxpQ0FBaUM7O0FBRXJFLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvaW5kZXguanM/Zjk3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmxlc3MgZXhwbGljaXRseSBzdGF0ZWQgb3RoZXJ3aXNlIGFsbCBmaWxlcyBpbiB0aGlzIHJlcG9zaXRvcnkgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIExpY2Vuc2UuXG4vL1xuLy8gVGhpcyBwcm9kdWN0IGluY2x1ZGVzIHNvZnR3YXJlIGRldmVsb3BlZCBhdCBEYXRhZG9nIChodHRwczovL3d3dy5kYXRhZG9naHEuY29tLykuIENvcHlyaWdodCAyMDIxIERhdGFkb2csIEluYy5cblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCdtb2R1bGUtZGV0YWlscy1mcm9tLXBhdGgnKVxuY29uc3QgeyBmaWxlVVJMVG9QYXRoIH0gPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgeyBNZXNzYWdlQ2hhbm5lbCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCB7XG4gIGltcG9ydEhvb2tzLFxuICBzcGVjaWZpZXJzLFxuICB0b0hvb2tcbn0gPSByZXF1aXJlKCcuL2xpYi9yZWdpc3RlcicpXG5cbmZ1bmN0aW9uIGFkZEhvb2sgKGhvb2spIHtcbiAgaW1wb3J0SG9va3MucHVzaChob29rKVxuICB0b0hvb2suZm9yRWFjaCgoW25hbWUsIG5hbWVzcGFjZV0pID0+IGhvb2sobmFtZSwgbmFtZXNwYWNlKSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSG9vayAoaG9vaykge1xuICBjb25zdCBpbmRleCA9IGltcG9ydEhvb2tzLmluZGV4T2YoaG9vaylcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICBpbXBvcnRIb29rcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2tGbiAoaG9va0ZuLCBuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpIHtcbiAgY29uc3QgbmV3RGVmYXVsdCA9IGhvb2tGbihuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpXG4gIGlmIChuZXdEZWZhdWx0ICYmIG5ld0RlZmF1bHQgIT09IG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZS5kZWZhdWx0ID0gbmV3RGVmYXVsdFxuICB9XG59XG5cbmxldCBzZW5kTW9kdWxlc1RvTG9hZGVyXG5cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKiBUaGlzIGZlYXR1cmUgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIG1pbm9yIHZlcnNpb25zLlxuICogKipOT1RFKiogVGhpcyBmZWF0dXJlIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSB7aW50ZXJuYWxzOiB0cnVlfSBIb29rIG9wdGlvbi5cbiAqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSBjaGFubmVsIHdpdGggYSBwb3J0IHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGhvb2tzIHRvIHRoZVxuICogbGlzdCBvZiBleGNsdXNpdmVseSBpbmNsdWRlZCBtb2R1bGVzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gb25seSB3cmFwIG1vZHVsZXMgdGhhdCBhcmUgSG9vaydlZCwgaG93ZXZlciBtb2R1bGVzIG5lZWRcbiAqIHRvIGJlIGhvb2tlZCBiZWZvcmUgdGhleSBhcmUgaW1wb3J0ZWQuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnbW9kdWxlJ1xuICogaW1wb3J0IHsgSG9vaywgY3JlYXRlQWRkSG9va01lc3NhZ2VDaGFubmVsIH0gZnJvbSAnaW1wb3J0LWluLXRoZS1taWRkbGUnXG4gKlxuICogY29uc3QgeyByZWdpc3Rlck9wdGlvbnMsIHdhaXRGb3JBbGxNZXNzYWdlc0Fja25vd2xlZGdlZCB9ID0gY3JlYXRlQWRkSG9va01lc3NhZ2VDaGFubmVsKClcbiAqXG4gKiByZWdpc3RlcignaW1wb3J0LWluLXRoZS1taWRkbGUvaG9vay5tanMnLCBpbXBvcnQubWV0YS51cmwsIHJlZ2lzdGVyT3B0aW9ucylcbiAqXG4gKiBIb29rKFsnZnMnXSwgKGV4cG9ydGVkLCBuYW1lLCBiYXNlRGlyKSA9PiB7XG4gKiAgIC8vIEluc3RydW1lbnQgdGhlIGZzIG1vZHVsZVxuICogfSlcbiAqXG4gKiAvLyBFbnN1cmUgdGhhdCB0aGUgbG9hZGVyIGhhcyBhY2tub3dsZWRnZWQgYWxsIHRoZSBtb2R1bGVzXG4gKiAvLyBiZWZvcmUgd2UgYWxsb3cgZXhlY3V0aW9uIHRvIGNvbnRpbnVlXG4gKiBhd2FpdCB3YWl0Rm9yQWxsTWVzc2FnZXNBY2tub3dsZWRnZWQoKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbCAoKSB7XG4gIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKVxuICBsZXQgcGVuZGluZ0Fja0NvdW50ID0gMFxuICBsZXQgcmVzb2x2ZUZuXG5cbiAgc2VuZE1vZHVsZXNUb0xvYWRlciA9IChtb2R1bGVzKSA9PiB7XG4gICAgcGVuZGluZ0Fja0NvdW50KytcbiAgICBwb3J0MS5wb3N0TWVzc2FnZShtb2R1bGVzKVxuICB9XG5cbiAgcG9ydDEub24oJ21lc3NhZ2UnLCAoKSA9PiB7XG4gICAgcGVuZGluZ0Fja0NvdW50LS1cblxuICAgIGlmIChyZXNvbHZlRm4gJiYgcGVuZGluZ0Fja0NvdW50IDw9IDApIHtcbiAgICAgIHJlc29sdmVGbigpXG4gICAgfVxuICB9KS51bnJlZigpXG5cbiAgZnVuY3Rpb24gd2FpdEZvckFsbE1lc3NhZ2VzQWNrbm93bGVkZ2VkICgpIHtcbiAgICAvLyBUaGlzIHRpbWVyIGlzIHRvIHByZXZlbnQgdGhlIHByb2Nlc3MgZnJvbSBleGl0aW5nIHdpdGggY29kZSAxMzpcbiAgICAvLyAxMzogVW5zZXR0bGVkIFRvcC1MZXZlbCBBd2FpdC5cbiAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMTAwMClcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGbiA9IHJlc29sdmVcbiAgICB9KS50aGVuKCgpID0+IHsgY2xlYXJJbnRlcnZhbCh0aW1lcikgfSlcblxuICAgIGlmIChwZW5kaW5nQWNrQ291bnQgPT09IDApIHtcbiAgICAgIHJlc29sdmVGbigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGNvbnN0IGFkZEhvb2tNZXNzYWdlUG9ydCA9IHBvcnQyXG4gIGNvbnN0IHJlZ2lzdGVyT3B0aW9ucyA9IHsgZGF0YTogeyBhZGRIb29rTWVzc2FnZVBvcnQsIGluY2x1ZGU6IFtdIH0sIHRyYW5zZmVyTGlzdDogW2FkZEhvb2tNZXNzYWdlUG9ydF0gfVxuXG4gIHJldHVybiB7IHJlZ2lzdGVyT3B0aW9ucywgYWRkSG9va01lc3NhZ2VQb3J0LCB3YWl0Rm9yQWxsTWVzc2FnZXNBY2tub3dsZWRnZWQgfVxufVxuXG5mdW5jdGlvbiBIb29rIChtb2R1bGVzLCBvcHRpb25zLCBob29rRm4pIHtcbiAgaWYgKCh0aGlzIGluc3RhbmNlb2YgSG9vaykgPT09IGZhbHNlKSByZXR1cm4gbmV3IEhvb2sobW9kdWxlcywgb3B0aW9ucywgaG9va0ZuKVxuICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBob29rRm4gPSBtb2R1bGVzXG4gICAgbW9kdWxlcyA9IG51bGxcbiAgICBvcHRpb25zID0gbnVsbFxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaG9va0ZuID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cbiAgY29uc3QgaW50ZXJuYWxzID0gb3B0aW9ucyA/IG9wdGlvbnMuaW50ZXJuYWxzID09PSB0cnVlIDogZmFsc2VcblxuICBpZiAoc2VuZE1vZHVsZXNUb0xvYWRlciAmJiBBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgc2VuZE1vZHVsZXNUb0xvYWRlcihtb2R1bGVzKVxuICB9XG5cbiAgdGhpcy5faWl0bUhvb2sgPSAobmFtZSwgbmFtZXNwYWNlKSA9PiB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBuYW1lXG4gICAgY29uc3QgaXNCdWlsdGluID0gbmFtZS5zdGFydHNXaXRoKCdub2RlOicpXG4gICAgbGV0IGJhc2VEaXJcblxuICAgIGlmIChpc0J1aWx0aW4pIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL15ub2RlOi8sICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuYW1lID0gZmlsZVVSTFRvUGF0aChuYW1lKVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgY29uc3QgZGV0YWlscyA9IHBhcnNlKG5hbWUpXG4gICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICBuYW1lID0gZGV0YWlscy5uYW1lXG4gICAgICAgIGJhc2VEaXIgPSBkZXRhaWxzLmJhc2VkaXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kdWxlcykge1xuICAgICAgZm9yIChjb25zdCBtb2R1bGVOYW1lIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgaWYgKG1vZHVsZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAoYmFzZURpcikge1xuICAgICAgICAgICAgaWYgKGludGVybmFscykge1xuICAgICAgICAgICAgICBuYW1lID0gbmFtZSArIHBhdGguc2VwICsgcGF0aC5yZWxhdGl2ZShiYXNlRGlyLCBmaWxlVVJMVG9QYXRoKGZpbGVuYW1lKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghYmFzZURpci5lbmRzV2l0aChzcGVjaWZpZXJzLmdldChmaWxlbmFtZSkpKSBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsSG9va0ZuKGhvb2tGbiwgbmFtZXNwYWNlLCBuYW1lLCBiYXNlRGlyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxIb29rRm4oaG9va0ZuLCBuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpXG4gICAgfVxuICB9XG5cbiAgYWRkSG9vayh0aGlzLl9paXRtSG9vaylcbn1cblxuSG9vay5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24gKCkge1xuICByZW1vdmVIb29rKHRoaXMuX2lpdG1Ib29rKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvb2tcbm1vZHVsZS5leHBvcnRzLkhvb2sgPSBIb29rXG5tb2R1bGUuZXhwb3J0cy5hZGRIb29rID0gYWRkSG9va1xubW9kdWxlLmV4cG9ydHMucmVtb3ZlSG9vayA9IHJlbW92ZUhvb2tcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbCA9IGNyZWF0ZUFkZEhvb2tNZXNzYWdlQ2hhbm5lbFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/import-in-the-middle/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/import-in-the-middle/lib/register.js":
/*!***********************************************************!*\
  !*** ./node_modules/import-in-the-middle/lib/register.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2.0 License.\n//\n// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2021 Datadog, Inc.\n\nconst importHooks = [] // TODO should this be a Set?\nconst setters = new WeakMap()\nconst getters = new WeakMap()\nconst specifiers = new Map()\nconst toHook = []\n\nconst proxyHandler = {\n  set (target, name, value) {\n    return setters.get(target)[name](value)\n  },\n\n  get (target, name) {\n    if (name === Symbol.toStringTag) {\n      return 'Module'\n    }\n\n    const getter = getters.get(target)[name]\n\n    if (typeof getter === 'function') {\n      return getter()\n    }\n  },\n\n  defineProperty (target, property, descriptor) {\n    if ((!('value' in descriptor))) {\n      throw new Error('Getters/setters are not supported for exports property descriptors.')\n    }\n\n    return setters.get(target)[property](descriptor.value)\n  }\n}\n\nfunction register (name, namespace, set, get, specifier) {\n  specifiers.set(name, specifier)\n  setters.set(namespace, set)\n  getters.set(namespace, get)\n  const proxy = new Proxy(namespace, proxyHandler)\n  importHooks.forEach(hook => hook(name, proxy))\n  toHook.push([name, proxy])\n}\n\nexports.register = register\nexports.importHooks = importHooks\nexports.specifiers = specifiers\nexports.toHook = toHook\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvbGliL3JlZ2lzdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanNtX2JhbmtpbmcvLi9ub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvbGliL3JlZ2lzdGVyLmpzPzEzZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RhdGVkIG90aGVyd2lzZSBhbGwgZmlsZXMgaW4gdGhpcyByZXBvc2l0b3J5IGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIDIuMCBMaWNlbnNlLlxuLy9cbi8vIFRoaXMgcHJvZHVjdCBpbmNsdWRlcyBzb2Z0d2FyZSBkZXZlbG9wZWQgYXQgRGF0YWRvZyAoaHR0cHM6Ly93d3cuZGF0YWRvZ2hxLmNvbS8pLiBDb3B5cmlnaHQgMjAyMSBEYXRhZG9nLCBJbmMuXG5cbmNvbnN0IGltcG9ydEhvb2tzID0gW10gLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBhIFNldD9cbmNvbnN0IHNldHRlcnMgPSBuZXcgV2Vha01hcCgpXG5jb25zdCBnZXR0ZXJzID0gbmV3IFdlYWtNYXAoKVxuY29uc3Qgc3BlY2lmaWVycyA9IG5ldyBNYXAoKVxuY29uc3QgdG9Ib29rID0gW11cblxuY29uc3QgcHJveHlIYW5kbGVyID0ge1xuICBzZXQgKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2V0dGVycy5nZXQodGFyZ2V0KVtuYW1lXSh2YWx1ZSlcbiAgfSxcblxuICBnZXQgKHRhcmdldCwgbmFtZSkge1xuICAgIGlmIChuYW1lID09PSBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgIHJldHVybiAnTW9kdWxlJ1xuICAgIH1cblxuICAgIGNvbnN0IGdldHRlciA9IGdldHRlcnMuZ2V0KHRhcmdldClbbmFtZV1cblxuICAgIGlmICh0eXBlb2YgZ2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0dGVyKClcbiAgICB9XG4gIH0sXG5cbiAgZGVmaW5lUHJvcGVydHkgKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoKCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2V0dGVycy9zZXR0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBleHBvcnRzIHByb3BlcnR5IGRlc2NyaXB0b3JzLicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRlcnMuZ2V0KHRhcmdldClbcHJvcGVydHldKGRlc2NyaXB0b3IudmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXIgKG5hbWUsIG5hbWVzcGFjZSwgc2V0LCBnZXQsIHNwZWNpZmllcikge1xuICBzcGVjaWZpZXJzLnNldChuYW1lLCBzcGVjaWZpZXIpXG4gIHNldHRlcnMuc2V0KG5hbWVzcGFjZSwgc2V0KVxuICBnZXR0ZXJzLnNldChuYW1lc3BhY2UsIGdldClcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkobmFtZXNwYWNlLCBwcm94eUhhbmRsZXIpXG4gIGltcG9ydEhvb2tzLmZvckVhY2goaG9vayA9PiBob29rKG5hbWUsIHByb3h5KSlcbiAgdG9Ib29rLnB1c2goW25hbWUsIHByb3h5XSlcbn1cblxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyXG5leHBvcnRzLmltcG9ydEhvb2tzID0gaW1wb3J0SG9va3NcbmV4cG9ydHMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnNcbmV4cG9ydHMudG9Ib29rID0gdG9Ib29rXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/import-in-the-middle/lib/register.js\n");

/***/ })

};
;